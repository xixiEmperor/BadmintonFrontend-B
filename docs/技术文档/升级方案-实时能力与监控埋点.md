## 升级方案：实时能力（Socket.IO）与监控/埋点（B 端 / C 端 / 后端 Express + Mongoose）

### 1. 背景与目标

- 统一实现实时能力与端到端观测：在 B 端（管理后台）与 C 端（用户前台）埋点采集 PV/UV、路由停留、关键交互、接口性能、错误日志、Web Vitals，并支持 Socket.IO 实时数据推送（订单、预约、消息等）。
- 后端（Express + Mongoose）建设可观测与配置能力：埋点采集接口、数据模型、清洗聚合、告警、远程配置/特性开关（Feature Flags）与 Socket.IO 服务端，实现消息发布/订阅、鉴权、限流、心跳与重连。
- 以最小侵入方式接入；可灰度、可配置、可审计，重视隐私合规（匿名化/脱敏、采样、DNT/Consent）。

> 注：此前文案中的“实施能力”为笔误，实际为“实时能力（Socket.IO/基于 WebSocket）”。

---

### 2. 总体架构（简要）

```mermaid
graph LR
  subgraph Frontends
    B[B 端 Admin SPA]
    C[C 端 Web/App]
  end

  subgraph SDKs
    T[Telemetry SDK\n(埋点/性能/错误 + 批量上报)]
    W[Socket.IO Client\n(重连/订阅/鉴权/心跳)]
  end

  subgraph Backend(Express)
    I[/POST /api/telemetry/batch\nGET /api/telemetry/config/]
    S((Socket.IO Server))
    F[/GET /api/flags\nGET /api/config/remote/]
  end

  M[(MongoDB\nMongoose Models)]

  B --> T
  C --> T
  B --> W
  C --> W

  T --> I
  I --> M
  S --> M
  F --> M
  W --> S
```

---

### 3. B 端（管理后台）方案（面向新手的落地步骤）

- 核心指标与事件
  - 路由：PV/路由进入/停留时长/跳出
  - 交互：按钮/菜单/批量操作/导出等关键事件（含业务上下文，如资源 ID）
  - 接口：成功率、状态码、耗时、重试、超时
  - 性能：Web Vitals（LCP/FID/CLS/INP/TTFB）、资源加载耗时
  - 错误：JS 运行时错误、Promise 未捕获错误、接口失败

#### 3.1 安装依赖（前端）

```bash
# 实时能力与性能指标
pnpm add socket.io-client web-vitals
```

#### 3.2 前端 Telemetry SDK（从 0 到 1）
- 位置：`src/monitoring/telemetry.ts`（本仓库已提供骨架 `Telemetry` 单例，可直接使用）
- 能力：初始化（app、release、user、采样率、endpoint）、`trackPageView/trackEvent/trackError/trackPerf/trackApi/setUser/flush`、离线缓存、批量上报、采样控制。
- 发送节流：数量阈值（如 20 条）/定时（如 10s）/页面隐藏（visibilitychange 与 pagehide）/恢复在线（online）。
- 可靠性：使用遥测专用队列 `createTelemetryTaskQueue` 实现低并发、指数退避与超时控制。

接入步骤：
1) 在应用入口初始化并注册全局监听（`src/main.tsx`）

```ts
// src/main.tsx（片段）
import { Telemetry } from '@/monitoring/telemetry'

Telemetry.init({
  app: 'admin',
  release: import.meta.env.VITE_APP_VERSION ?? 'dev',
  endpoint: '/api/telemetry/batch',
  user: undefined,
  sampleRate: 1,
})

// 页面隐藏/卸载时尽力上报
document.addEventListener('visibilitychange', () => {
  if (document.visibilityState === 'hidden') Telemetry.flush()
})
window.addEventListener('pagehide', () => Telemetry.flush())

// 全局错误捕获
window.addEventListener('error', (e) => {
  Telemetry.trackError('GlobalError', e.message, e.error?.stack)
})
window.addEventListener('unhandledrejection', (e) => {
  Telemetry.trackError('UnhandledRejection', String(e.reason))
})
```

2) 记录路由曝光与停留（在根组件中监听 `useLocation()`）

```tsx
// 示例：在根布局或专用组件中
import { useEffect, useRef } from 'react'
import { useLocation } from 'react-router-dom'
import { Telemetry } from '@/monitoring/telemetry'

function PageViewTracker() {
  const location = useLocation()
  const enterAtRef = useRef<number>(Date.now())

  useEffect(() => {
    const path = location.pathname + location.search
    // 上报进入
    Telemetry.trackPageView(path, { referrer: document.referrer })
    // 记录进入时间
    enterAtRef.current = Date.now()

    return () => {
      const stayMs = Date.now() - enterAtRef.current
      Telemetry.trackEvent('page.stay', { path, stayMs })
    }
  }, [location])
  return null
}
```

3) 接入 Web Vitals 性能指标

```ts
// 在入口或任意首次渲染位置调用一次
import { onCLS, onFID, onLCP, onINP, onTTFB } from 'web-vitals'
import { Telemetry } from '@/monitoring/telemetry'

onCLS((m) => Telemetry.trackPerf('web-vitals', { CLS: m.value }))
onFID((m) => Telemetry.trackPerf('web-vitals', { FID: m.value }))
onLCP((m) => Telemetry.trackPerf('web-vitals', { LCP: m.value }))
onINP((m) => Telemetry.trackPerf('web-vitals', { INP: m.value }))
onTTFB((m) => Telemetry.trackPerf('web-vitals', { TTFB: m.value }))
```

4) 在 `src/utils/request.ts` 拦截器中记录接口埋点

```ts
// src/utils/request.ts（片段，按需合并到现有拦截器）
import { Telemetry } from '@/monitoring/telemetry'

instance.interceptors.request.use((config) => {
  ;(config as any).metadata = { start: performance.now() }
  return config
})

instance.interceptors.response.use(
  (res) => {
    const start = (res.config as any).metadata?.start ?? performance.now()
    const durationMs = Math.round(performance.now() - start)
    Telemetry.trackApi(`${res.config.method?.toUpperCase()} ${res.config.url}`, res.status, durationMs)
    return Promise.resolve(res.data)
  },
  (err) => {
    const cfg = err.config ?? {}
    const start = (cfg as any).metadata?.start ?? performance.now()
    const durationMs = Math.round(performance.now() - start)
    const status = err.response?.status ?? 0
    Telemetry.trackApi(`${cfg.method?.toUpperCase()} ${cfg.url}`, status, durationMs, { reason: err.message })
    return Promise.reject(err)
  },
)
```

- 路由与性能埋点实践
  - 在根路由组件使用 `useLocation()` 监听变更：进入时 `trackPageView`，离开时上报停留时长。
  - 接入 `web-vitals`，采集 LCP/FID/CLS/INP/TTFB，通过 `trackPerf` 上报。

- 接口埋点实践
  - 在 `src/utils/request.ts` 拦截器里记录：开始时间、结束时间、状态码、失败原因，统一 `trackEvent('api_call', {...})`。

#### 3.3 实时能力（改用 Socket.IO，前端从 0 到 1）

- 建议封装 `useSocketIO` Hook（新手友好：无需手写心跳，自动重连内置）
- 鉴权：使用 `io(url, { auth: { token } })` 或查询参数
- 房间订阅：连接成功后 emit `join`，由服务端 `socket.join(room)`
- 去抖合并：对高频消息做 200~500ms 合并再渲染

最小可用示例（可复制到 `src/hooks/useSocketIO.ts` 自建）：

```ts
import { useEffect, useMemo, useRef, useState } from 'react'
import { io, Socket } from 'socket.io-client'

export interface UseSocketIOOptions {
  url: string // 如 http://localhost:8080
  token?: string
  autoJoinRooms?: string[] // 例如 ['role:admin']
}

export function useSocketIO<T = unknown>({ url, token, autoJoinRooms = [] }: UseSocketIOOptions) {
  const socketRef = useRef<Socket | null>(null)
  const [connected, setConnected] = useState(false)
  const [lastMessage, setLastMessage] = useState<T | null>(null)

  useEffect(() => {
    const socket = io(url, {
      transports: ['websocket'],
      auth: token ? { token } : undefined,
      reconnection: true,
      reconnectionAttempts: Infinity,
      reconnectionDelay: 1000,
      reconnectionDelayMax: 30000,
    })
    socketRef.current = socket

    socket.on('connect', () => {
      setConnected(true)
      // 加入房间
      if (autoJoinRooms.length > 0) socket.emit('join', autoJoinRooms)
    })

    socket.on('disconnect', () => setConnected(false))
    socket.on('connect_error', (err) => console.warn('socket connect_error:', err.message))

    // 统一的数据事件（示例）：服务端广播 { type, payload }
    socket.on('message', (data: T) => setLastMessage(data))

    return () => {
      socket.removeAllListeners()
      socket.disconnect()
      socketRef.current = null
    }
  }, [url, token, autoJoinRooms])

  const api = useMemo(() => ({
    emit: (event: string, payload?: unknown) => socketRef.current?.emit(event, payload),
    on: (event: string, handler: (...args: any[]) => void) => {
      socketRef.current?.on(event, handler)
      return () => socketRef.current?.off(event, handler)
    },
  }), [])

  return { connected, lastMessage, ...api }
}
```

页面使用示例（订单/预约实时刷新）：

```tsx
import { useEffect, useMemo, useState } from 'react'
import { useSocketIO } from '@/hooks/useSocketIO' // 若你将上面 Hook 存在此处

export default function OrdersRealtime() {
  const token = localStorage.getItem('token') ?? undefined
  const { connected, on } = useSocketIO({ url: 'http://localhost:8080', token, autoJoinRooms: ['role:admin'] })
  const [updates, setUpdates] = useState<any[]>([])

  // 200ms 合并高频更新
  useEffect(() => {
    const buffer: any[] = []
    const stop = on('order:update', (p) => buffer.push(p))
    const timer = setInterval(() => {
      if (buffer.length > 0) {
        setUpdates((prev) => [...buffer, ...prev])
        buffer.length = 0
      }
    }, 200)
    return () => { stop?.(); clearInterval(timer) }
  }, [on])

  return <div>{connected ? '实时已连接' : '离线'}</div>
}
```

- 配置/灰度
  - `GET /api/telemetry/config`：返回采样率、禁用字段、允许上报事件白名单
  - `GET /api/flags`：返回特性开关与灰度规则；前端按开关控制埋点与实时订阅范围

---

### 4. C 端（用户前台）方案

- 基本同 B 端，但更重视隐私与端能力差异：
  - 更严格的采样（默认 1%~5%）、尊重 DNT/Consent、避免上报 PII（邮箱/手机号需哈希或脱敏）
  - 实时能力用于：订单状态、预约状态、消息/通知、聊天室等
  - 移动端注意弱网：离线缓存 + 延迟上报，重连策略更保守

---

### 5. 后端（Express + Mongoose）实现（含 Socket.IO 详细示例）

#### 5.1 埋点采集接口
- 路由
  - `POST /api/telemetry/batch`：批量接收事件
  - `GET /api/telemetry/config`：返回采样率、字段白/黑名单、最大批次大小、最大发送间隔等
- 数据结构（Mongoose Schema 示例字段）
  - `TelemetryEvent`：`app`, `env`, `release`, `userId`, `sessionId`, `type`(page/event/error/perf/api), `name`, `props`, `ts`
  - TTL/分片
    - 对大体量表（如 `TelemetryEvent`）设 `ttl` 索引（如 30~90 天）
    - 关键聚合结果长期保存到专门 `Agg` 集合（日报/小时）
- 保护
  - 身份：校验上报来源（JWT / HMAC 签名），限制匿名上报域名
  - 限流：IP + User 级速率限制（如 60 req/min）
  - 校验：最大负载、字段白名单、字段脱敏（邮箱/手机号哈希，IP 仅保留 /24 网段）

#### 5.2 Socket.IO 服务（替代原生 WebSocket）

安装（后端）：
```bash
npm i express socket.io cors
```

最小可用服务端（可直接复用/扩展）：

```ts
// server.ts（示例）
import express from 'express'
import http from 'http'
import { Server } from 'socket.io'
import cors from 'cors'

const app = express()
app.use(cors({ origin: ['http://localhost:5173'], credentials: true }))
app.use(express.json())

// 示例：遥测批量接收
app.post('/api/telemetry/batch', (req, res) => {
  // TODO: 入库与校验
  res.json({ ok: true })
})

const server = http.createServer(app)
const io = new Server(server, {
  cors: { origin: ['http://localhost:5173'], credentials: true },
})

// 简单 JWT 鉴权示例（替换为你自己的校验逻辑）
io.use((socket, next) => {
  const token = (socket.handshake.auth as any)?.token || socket.handshake.query?.token
  // TODO: 校验 token，并解析出 userId/role
  ;(socket as any).user = { id: '123', role: 'admin' }
  return next()
})

io.on('connection', (socket) => {
  const user = (socket as any).user
  // 按角色/用户加入默认房间
  socket.join(`user:${user.id}`)
  socket.join(`role:${user.role}`)

  // 客户端可主动 join 多个房间
  socket.on('join', (rooms: string[] | string) => {
    const list = Array.isArray(rooms) ? rooms : [rooms]
    list.forEach((r) => socket.join(r))
  })

  // 示例：主动响应健康检查
  socket.on('ping', () => socket.emit('pong', { ts: Date.now() }))

  socket.on('disconnect', (reason) => {
    console.log('socket disconnected:', reason)
  })
})

// 业务层广播示例：订单/预约状态更新时调用
function broadcastReservationUpdate(payload: any) {
  io.to('role:admin').emit('reservation:update', payload)
}
function broadcastOrderUpdate(userId: string, payload: any) {
  io.to(`user:${userId}`).emit('order:update', payload)
}

server.listen(8080, () => console.log('HTTP + Socket.IO listening on :8080'))
```

要点：
- 鉴权：优先使用 `handshake.auth.token`；用完删除敏感字段
- 心跳：Socket.IO 内置，通常无需手写；可保留 `ping`/`pong` 作为业务心跳
- 广播：优先基于房间（role/user）；高频广播在业务层做 100ms 合并
- 反压：限制单连接的发包速率，并在广播前合并

#### 5.3 聚合与告警
- 定时聚合（node-cron）：
  - T+1/小时聚合：PV/UV、接口成功率 P95/P99、错误 TopK、性能指标分位数
  - 结果落地 `AggTelemetryHourly`/`AggTelemetryDaily`
- 告警（Webhook 到飞书/钉钉/Slack）
  - 规则示例：错误率 > 2%，接口 P95 > 1.5s，WS 丢包/断开率 > 5%
  - 去抖：同一规则 N 分钟内只告警一次；支持手动确认与静默窗口

#### 5.4 远程配置/特性开关（Flags）
- 路由
  - `GET /api/flags`：按用户/角色/环境返回开关
  - `GET /api/config/remote`：返回远程配置（包含 telemetry 采样率与 WS 配置）
- 存储
  - `FeatureFlag`：`key`, `enabled`, `rules`（如角色/百分比灰度）、`startAt`/`endAt`

#### 5.5 合规与安全
- 隐私最小化：默认关闭 PII；如需使用，必须显式配置并脱敏
- 采样与匿名化：默认 1% 采样（C 端）；IP/UA 并行用以大盘分析，避免存储原始 IP
- 跨站与注入：严格 CORS 白名单、JSON schema 校验、截断超长字段

---

### 6. 前后端对接：事件与载荷规范（示例）

- `page_view`
  - 示例：`{ type: 'page', name: '/admin/orders', ts, referrer, stayMs, user: { id, role } }`
- `event`
  - 示例：`{ type: 'event', name: 'product.off_sale', props: { productId }, ts }`
- `api_call`
  - 示例：`{ type: 'api', name: 'GET /api/mall/orders/admin', status: 200, durationMs: 123, ts }`
- `perf`
  - 示例：`{ type: 'perf', name: 'web-vitals', props: { LCP, FID, CLS, INP, TTFB }, ts }`
- `error`
  - 示例：`{ type: 'error', name: 'UnhandledRejection', message, stack, fatal: false, ts }`

- Socket.IO 实时事件
  - `reservation:update`：`{ id, status, updatedBy, ts }`
  - `order:update`：`{ id, status, userId, ts }`
  - 客户端可统一经由 `message` 或分别监听具体事件名

---

### 7. 迭代与验收（建议节奏）

- 第 1 期（1 周）
  - 后端：`/api/telemetry/batch`、`/api/telemetry/config`、Mongoose 模型 + TTL、基础聚合脚本
  - B 端：SDK 初始化、路由与接口埋点，批量上报（TaskQueue），看板初版（按天统计）
  - 验收：无卡死/内存泄漏；上报成功率 > 99%；看板数据 T+1 一致
- 第 2 期（1~2 周）
  - Socket.IO：鉴权、自动重连、订阅（房间）；B 端订单/预约实时刷新
  - 告警：错误率与接口延迟规则，Webhook 联动
  - 验收：断网/重连稳定；推送延迟 P95 < 1s；误告警率低
- 第 3 期（按需）
  - C 端 SDK 接入、A/B 实验、远程配置面板、更多可视化大盘

---

### 8. 与现有代码对齐与落地点位（本仓库指引）

- 前端
  - 请求封装：`src/utils/request.ts` 请求/响应拦截点插桩，统一 `api_call`
  - 队列：在 `src/utils/TaskQueue.ts` 基础上，新建 `createTelemetryTaskQueue`（与商品规格队列类似配置，更偏可靠/低并发）
  - 入口：在 `src/main.tsx` 初始化 Telemetry（读取远程配置）、注册错误捕获（`window.onerror` / `unhandledrejection`）
- 路由：`src/router/index.tsx` 或根布局中监听 `useLocation()`（见 3.2 的 `PageViewTracker` 示例）
- 实时能力：建议新增 `hooks/useSocketIO.ts`（自动重连/订阅/鉴权），在订单、预约等页面按需使用

- 后端（新加）
  - 路由：`/api/telemetry/batch`、`/api/telemetry/config`、`/api/flags`
  - 模型：`TelemetryEvent`, `AggTelemetryHourly`, `FeatureFlag`
- 实时服务：`socket.io` 服务；业务事件触发时 emit 到相应房间

---

### 9. 任务队列实现对齐说明（参考 TaskQueue.js）

你提供的 `TaskQueue.js` 具备更完善的说明与更丰富的能力（优先级、指数退避、暂停/恢复/停止、进度/结果汇总、任务级配置覆盖等）。建议：

- 前端：
  - 保留现有 `src/utils/TaskQueue.ts` 用于业务批量（如商品规格），并新增一个“遥测专用队列”工厂：`createTelemetryTaskQueue({ maxConcurrent: 2, requestInterval: 200, maxRetries: 3, retryDelay: 1500, timeout: 10000 })`，在埋点 SDK 内部使用，避免对页面交互造成压力。
  - 进度订阅用于调试模式；线上采样 + 静默运行。

- 后端（可选）：
  - 在聚合脚本或外部采集器中，也可重用同理念（Node 侧队列 + 指数退避）处理第三方回传或消息推送任务。

如需，我可以将 `TaskQueue.js` 迁移为 TypeScript 并与现有 `TaskQueue.ts` 合并为单一高能力实现（保留现用 API），以减少心智成本。

---

### 10. 合规与安全清单（上线前核对）

- **采样与开关**：默认 C 端 1% 采样，B 端 5%，可远程下发；可一键关闭全部埋点
- **PII**：邮箱/手机号做哈希；IP 仅保留网段；支持 DNT/Consent
- **限流**：上报接口限流；WS 连接数限制与广播节流
- **数据留存**：事件 TTL（30~90 天）；聚合表长期保存
- **容灾**：上报端离线缓存；服务端 5xx 退避重试；WS 热更新与平滑重启

---

### 11. 新手快速上手清单（复制即用）

- 安装：`pnpm add socket.io-client web-vitals`
- 入口初始化：在 `src/main.tsx` 调用 `Telemetry.init(...)`，注册 `visibilitychange/pagehide/error/unhandledrejection`
- 路由曝光：在根组件放置 `PageViewTracker`
- 接口埋点：在 `src/utils/request.ts` 的请求/响应拦截器中记录 `start` 和 `durationMs`，调用 `Telemetry.trackApi`
- 性能指标：调用 `onCLS/onFID/onLCP/onINP/onTTFB` 并 `Telemetry.trackPerf`
- 实时能力：创建 `src/hooks/useSocketIO.ts`（见 3.3），在列表页订阅 `reservation:update`/`order:update`
- 后端：用示例 `server.ts` 启动 `Socket.IO`，在业务操作完成后广播到房间

做到以上六步，即可拥有“埋点 + 实时推送”的最小可用闭环。


