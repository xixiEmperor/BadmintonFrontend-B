# 前端高级功能实现文档

## 目录

- [实时通知系统](#实时通知系统)
- [文件上传管理](#文件上传管理)
- [PWA支持](#pwa支持)

---

## 实时通知系统

### 技术架构

**WebSocket + 消息队列 + React状态管理**

### 1. WebSocket连接管理

#### 创建WebSocket服务

```typescript:src%2Fservices%2Fwebsocket.ts
class WebSocketService {
  private ws: WebSocket | null = null
  private reconnectAttempts = 0
  private maxReconnectAttempts = 5
  private reconnectInterval = 3000
  private messageQueue: any[] = []
  private listeners: Map<string, Function[]> = new Map()

  connect(url: string, token: string) {
    try {
      this.ws = new WebSocket(`${url}?token=${token}`)
      this.setupEventHandlers()
    } catch (error) {
      console.error('WebSocket连接失败:', error)
      this.handleReconnect()
    }
  }

  private setupEventHandlers() {
    if (!this.ws) return

    this.ws.onopen = () => {
      console.log('WebSocket连接成功')
      this.reconnectAttempts = 0
      this.flushMessageQueue()
    }

    this.ws.onmessage = (event) => {
      const data = JSON.parse(event.data)
      this.handleMessage(data)
    }

    this.ws.onclose = () => {
      console.log('WebSocket连接关闭')
      this.handleReconnect()
    }

    this.ws.onerror = (error) => {
      console.error('WebSocket错误:', error)
    }
  }

  private handleReconnect() {
    if (this.reconnectAttempts < this.maxReconnectAttempts) {
      setTimeout(() => {
        this.reconnectAttempts++
        this.connect(this.url, this.token)
      }, this.reconnectInterval)
    }
  }

  // 消息订阅
  subscribe(type: string, callback: Function) {
    if (!this.listeners.has(type)) {
      this.listeners.set(type, [])
    }
    this.listeners.get(type)?.push(callback)
  }

  // 发送消息
  send(message: any) {
    if (this.ws?.readyState === WebSocket.OPEN) {
      this.ws.send(JSON.stringify(message))
    } else {
      this.messageQueue.push(message)
    }
  }
}

export const wsService = new WebSocketService()
```

#### React Hook封装

```typescript:src%2Fhooks%2FuseWebSocket.ts
import { useEffect, useCallback } from 'react'
import { wsService } from '@/services/websocket'

export const useWebSocket = () => {
  const [notifications, setNotifications] = useState<Notification[]>([])
  const [isConnected, setIsConnected] = useState(false)

  useEffect(() => {
    const token = localStorage.getItem('token')
    if (token) {
      wsService.connect('ws://localhost:8080/ws', token)
    }

    // 订阅通知消息
    wsService.subscribe('notification', (data: any) => {
      setNotifications(prev => [data, ...prev])
      // 显示浏览器通知
      if (Notification.permission === 'granted') {
        new Notification(data.title, {
          body: data.content,
          icon: '/favicon.ico'
        })
      }
    })

    wsService.subscribe('connect', () => setIsConnected(true))
    wsService.subscribe('disconnect', () => setIsConnected(false))

    return () => {
      wsService.disconnect()
    }
  }, [])

  const sendMessage = useCallback((message: any) => {
    wsService.send(message)
  }, [])

  return {
    notifications,
    isConnected,
    sendMessage,
    clearNotifications: () => setNotifications([])
  }
}
```

### 2. 通知组件实现

```typescript:src%2Fcomponents%2FNotification%2FNotificationCenter.tsx
import { Bell, X } from 'lucide-react'
import { useWebSocket } from '@/hooks/useWebSocket'

export const NotificationCenter = () => {
  const { notifications, clearNotifications } = useWebSocket()
  const [isOpen, setIsOpen] = useState(false)

  return (
    <div className="relative">
      {/* 通知铃铛 */}
      <button 
        onClick={() => setIsOpen(!isOpen)}
        className="relative p-2 text-gray-600 hover:text-gray-900"
      >
        <Bell size={20} />
        {notifications.length > 0 && (
          <span className="absolute -top-1 -right-1 bg-red-500 text-white text-xs rounded-full h-5 w-5 flex items-center justify-center">
            {notifications.length}
          </span>
        )}
      </button>

      {/* 通知面板 */}
      {isOpen && (
        <div className="absolute right-0 mt-2 w-80 bg-white rounded-lg shadow-lg border z-50">
          <div className="p-4 border-b flex justify-between items-center">
            <h3 className="font-semibold">通知中心</h3>
            <button onClick={clearNotifications} className="text-sm text-blue-600">
              清空全部
            </button>
          </div>
        
          <div className="max-h-96 overflow-y-auto">
            {notifications.length === 0 ? (
              <div className="p-4 text-center text-gray-500">
                暂无通知
              </div>
            ) : (
              notifications.map((notification, index) => (
                <div key={index} className="p-4 border-b hover:bg-gray-50">
                  <div className="flex justify-between items-start">
                    <div className="flex-1">
                      <h4 className="font-medium text-sm">{notification.title}</h4>
                      <p className="text-gray-600 text-sm mt-1">{notification.content}</p>
                      <span className="text-xs text-gray-400 mt-2 block">
                        {new Date(notification.timestamp).toLocaleString()}
                      </span>
                    </div>
                  </div>
                </div>
              ))
            )}
          </div>
        </div>
      )}
    </div>
  )
}
```

### 3. 消息队列处理

```typescript:src%2Fservices%2FmessageQueue.ts
class MessageQueue {
  private queue: any[] = []
  private processing = false

  // 添加消息到队列
  enqueue(message: any) {
    this.queue.push({
      ...message,
      timestamp: Date.now(),
      id: Math.random().toString(36).substr(2, 9)
    })
    this.process()
  }

  // 处理队列中的消息
  private async process() {
    if (this.processing || this.queue.length === 0) return
  
    this.processing = true
  
    while (this.queue.length > 0) {
      const message = this.queue.shift()
      try {
        await this.handleMessage(message)
      } catch (error) {
        console.error('消息处理失败:', error)
        // 重新入队或记录错误
      }
    }
  
    this.processing = false
  }

  private async handleMessage(message: any) {
    switch (message.type) {
      case 'notification':
        // 处理通知消息
        break
      case 'update':
        // 处理数据更新
        break
      default:
        console.warn('未知消息类型:', message.type)
    }
  }
}

export const messageQueue = new MessageQueue()
```

---

## 文件上传管理

### 技术架构

**分片上传 + 断点续传 + 进度监控**

### 1. 分片上传核心实现

```typescript:src%2Fservices%2Fupload.ts
interface ChunkInfo {
  file: File
  chunkSize: number
  chunks: Blob[]
  uploadedChunks: Set<number>
  uploadId: string
}

class UploadService {
  private chunkSize = 2 * 1024 * 1024 // 2MB
  private maxConcurrent = 3 // 最大并发数
  private uploads: Map<string, ChunkInfo> = new Map()

  // 开始上传
  async startUpload(file: File, onProgress?: (progress: number) => void): Promise<string> {
    const uploadId = this.generateUploadId()
    const chunks = this.createChunks(file)
  
    const chunkInfo: ChunkInfo = {
      file,
      chunkSize: this.chunkSize,
      chunks,
      uploadedChunks: new Set(),
      uploadId
    }
  
    this.uploads.set(uploadId, chunkInfo)
  
    // 检查是否有已上传的分片（断点续传）
    await this.checkUploadedChunks(uploadId)
  
    // 开始并发上传
    await this.uploadChunks(uploadId, onProgress)
  
    // 合并分片
    return await this.mergeChunks(uploadId)
  }

  // 创建文件分片
  private createChunks(file: File): Blob[] {
    const chunks: Blob[] = []
    let start = 0
  
    while (start < file.size) {
      const end = Math.min(start + this.chunkSize, file.size)
      chunks.push(file.slice(start, end))
      start = end
    }
  
    return chunks
  }

  // 检查已上传的分片
  private async checkUploadedChunks(uploadId: string) {
    try {
      const response = await fetch(`/api/upload/check/${uploadId}`)
      const { uploadedChunks } = await response.json()
    
      const chunkInfo = this.uploads.get(uploadId)
      if (chunkInfo) {
        chunkInfo.uploadedChunks = new Set(uploadedChunks)
      }
    } catch (error) {
      console.error('检查上传状态失败:', error)
    }
  }

  // 并发上传分片
  private async uploadChunks(uploadId: string, onProgress?: (progress: number) => void) {
    const chunkInfo = this.uploads.get(uploadId)
    if (!chunkInfo) throw new Error('上传信息不存在')
  
    const { chunks, uploadedChunks } = chunkInfo
    const pendingChunks = chunks
      .map((_, index) => index)
      .filter(index => !uploadedChunks.has(index))
  
    // 并发控制
    const semaphore = new Semaphore(this.maxConcurrent)
  
    const uploadPromises = pendingChunks.map(async (chunkIndex) => {
      await semaphore.acquire()
    
      try {
        await this.uploadChunk(uploadId, chunkIndex)
        uploadedChunks.add(chunkIndex)
      
        // 更新进度
        if (onProgress) {
          const progress = (uploadedChunks.size / chunks.length) * 100
          onProgress(progress)
        }
      } finally {
        semaphore.release()
      }
    })
  
    await Promise.all(uploadPromises)
  }

  // 上传单个分片
  private async uploadChunk(uploadId: string, chunkIndex: number): Promise<void> {
    const chunkInfo = this.uploads.get(uploadId)
    if (!chunkInfo) throw new Error('上传信息不存在')
  
    const chunk = chunkInfo.chunks[chunkIndex]
    const formData = new FormData()
  
    formData.append('chunk', chunk)
    formData.append('chunkIndex', chunkIndex.toString())
    formData.append('uploadId', uploadId)
    formData.append('totalChunks', chunkInfo.chunks.length.toString())
  
    const response = await fetch('/api/upload/chunk', {
      method: 'POST',
      body: formData
    })
  
    if (!response.ok) {
      throw new Error(`分片${chunkIndex}上传失败`)
    }
  }

  // 合并分片
  private async mergeChunks(uploadId: string): Promise<string> {
    const response = await fetch('/api/upload/merge', {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json'
      },
      body: JSON.stringify({ uploadId })
    })
  
    const { fileUrl } = await response.json()
    this.uploads.delete(uploadId)
  
    return fileUrl
  }

  // 暂停上传
  pauseUpload(uploadId: string) {
    // 实现暂停逻辑
  }

  // 恢复上传
  resumeUpload(uploadId: string) {
    // 实现恢复逻辑
  }

  // 取消上传
  cancelUpload(uploadId: string) {
    this.uploads.delete(uploadId)
  }

  private generateUploadId(): string {
    return `upload_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`
  }
}

// 信号量实现并发控制
class Semaphore {
  private permits: number
  private waitQueue: (() => void)[] = []

  constructor(permits: number) {
    this.permits = permits
  }

  async acquire(): Promise<void> {
    return new Promise((resolve) => {
      if (this.permits > 0) {
        this.permits--
        resolve()
      } else {
        this.waitQueue.push(resolve)
      }
    })
  }

  release(): void {
    this.permits++
    if (this.waitQueue.length > 0) {
      const resolve = this.waitQueue.shift()!
      this.permits--
      resolve()
    }
  }
}

export const uploadService = new UploadService()
```

### 2. 上传组件实现

```typescript:src%2Fcomponents%2FUpload%2FChunkUpload.tsx
import { useState, useRef } from 'react'
import { Upload, X, Pause, Play, RotateCcw } from 'lucide-react'
import { uploadService } from '@/services/upload'

interface UploadItem {
  id: string
  file: File
  progress: number
  status: 'uploading' | 'paused' | 'completed' | 'error'
  url?: string
}

export const ChunkUpload = () => {
  const [uploadItems, setUploadItems] = useState<UploadItem[]>([])
  const fileInputRef = useRef<HTMLInputElement>(null)

  const handleFileSelect = (event: React.ChangeEvent<HTMLInputElement>) => {
    const files = Array.from(event.target.files || [])
  
    files.forEach(file => {
      const uploadItem: UploadItem = {
        id: Math.random().toString(36).substr(2, 9),
        file,
        progress: 0,
        status: 'uploading'
      }
    
      setUploadItems(prev => [...prev, uploadItem])
    
      // 开始上传
      uploadService.startUpload(file, (progress) => {
        setUploadItems(prev => 
          prev.map(item => 
            item.id === uploadItem.id 
              ? { ...item, progress }
              : item
          )
        )
      }).then(url => {
        setUploadItems(prev => 
          prev.map(item => 
            item.id === uploadItem.id 
              ? { ...item, status: 'completed', url, progress: 100 }
              : item
          )
        )
      }).catch(error => {
        setUploadItems(prev => 
          prev.map(item => 
            item.id === uploadItem.id 
              ? { ...item, status: 'error' }
              : item
          )
        )
      })
    })
  }

  const removeUploadItem = (id: string) => {
    setUploadItems(prev => prev.filter(item => item.id !== id))
  }

  return (
    <div className="w-full max-w-2xl mx-auto p-6">
      {/* 上传区域 */}
      <div 
        className="border-2 border-dashed border-gray-300 rounded-lg p-8 text-center hover:border-gray-400 transition-colors cursor-pointer"
        onClick={() => fileInputRef.current?.click()}
      >
        <Upload className="mx-auto h-12 w-12 text-gray-400" />
        <p className="mt-2 text-sm text-gray-600">
          点击选择文件或拖拽文件到此处
        </p>
        <p className="text-xs text-gray-500 mt-1">
          支持大文件上传，自动分片处理
        </p>
      </div>
    
      <input
        ref={fileInputRef}
        type="file"
        multiple
        className="hidden"
        onChange={handleFileSelect}
      />

      {/* 上传列表 */}
      {uploadItems.length > 0 && (
        <div className="mt-6 space-y-4">
          {uploadItems.map(item => (
            <div key={item.id} className="bg-white rounded-lg border p-4">
              <div className="flex items-center justify-between">
                <div className="flex-1">
                  <h4 className="text-sm font-medium text-gray-900">
                    {item.file.name}
                  </h4>
                  <p className="text-xs text-gray-500">
                    {(item.file.size / 1024 / 1024).toFixed(2)} MB
                  </p>
                </div>
              
                <div className="flex items-center space-x-2">
                  {item.status === 'uploading' && (
                    <button className="p-1 text-gray-400 hover:text-gray-600">
                      <Pause size={16} />
                    </button>
                  )}
                
                  {item.status === 'paused' && (
                    <button className="p-1 text-gray-400 hover:text-gray-600">
                      <Play size={16} />
                    </button>
                  )}
                
                  {item.status === 'error' && (
                    <button className="p-1 text-gray-400 hover:text-gray-600">
                      <RotateCcw size={16} />
                    </button>
                  )}
                
                  <button 
                    onClick={() => removeUploadItem(item.id)}
                    className="p-1 text-gray-400 hover:text-red-600"
                  >
                    <X size={16} />
                  </button>
                </div>
              </div>
            
              {/* 进度条 */}
              <div className="mt-3">
                <div className="flex justify-between text-xs text-gray-600 mb-1">
                  <span>{item.status === 'completed' ? '上传完成' : `上传中 ${item.progress.toFixed(1)}%`}</span>
                  <span>{item.status}</span>
                </div>
                <div className="w-full bg-gray-200 rounded-full h-2">
                  <div 
                    className={`h-2 rounded-full transition-all duration-300 ${
                      item.status === 'error' ? 'bg-red-500' : 
                      item.status === 'completed' ? 'bg-green-500' : 'bg-blue-500'
                    }`}
                    style={{ width: `${item.progress}%` }}
                  />
                </div>
              </div>
            </div>
          ))}
        </div>
      )}
    </div>
  )
}
```

---

## PWA支持

### 技术架构

**Service Worker + Web App Manifest + 缓存策略**

### 1. Web App Manifest配置

```json:public%2Fmanifest.json
{
  "name": "Admin Frontend",
  "short_name": "Admin",
  "description": "后台管理系统",
  "start_url": "/",
  "display": "standalone",
  "background_color": "#ffffff",
  "theme_color": "#000000",
  "orientation": "portrait-primary",
  "icons": [
    {
      "src": "/icons/icon-72x72.png",
      "sizes": "72x72",
      "type": "image/png",
      "purpose": "maskable any"
    },
    {
      "src": "/icons/icon-96x96.png",
      "sizes": "96x96",
      "type": "image/png",
      "purpose": "maskable any"
    },
    {
      "src": "/icons/icon-128x128.png",
      "sizes": "128x128",
      "type": "image/png",
      "purpose": "maskable any"
    },
    {
      "src": "/icons/icon-144x144.png",
      "sizes": "144x144",
      "type": "image/png",
      "purpose": "maskable any"
    },
    {
      "src": "/icons/icon-152x152.png",
      "sizes": "152x152",
      "type": "image/png",
      "purpose": "maskable any"
    },
    {
      "src": "/icons/icon-192x192.png",
      "sizes": "192x192",
      "type": "image/png",
      "purpose": "maskable any"
    },
    {
      "src": "/icons/icon-384x384.png",
      "sizes": "384x384",
      "type": "image/png",
      "purpose": "maskable any"
    },
    {
      "src": "/icons/icon-512x512.png",
      "sizes": "512x512",
      "type": "image/png",
      "purpose": "maskable any"
    }
  ],
  "categories": ["business", "productivity"],
  "screenshots": [
    {
      "src": "/screenshots/desktop.png",
      "sizes": "1280x720",
      "type": "image/png",
      "form_factor": "wide"
    },
    {
      "src": "/screenshots/mobile.png",
      "sizes": "375x667",
      "type": "image/png",
      "form_factor": "narrow"
    }
  ]
}
```

### 2. Service Worker实现

```javascript:public%2Fsw.js
const CACHE_NAME = 'admin-frontend-v1'
const API_CACHE_NAME = 'admin-api-v1'

// 需要缓存的静态资源
const STATIC_CACHE_URLS = [
  '/',
  '/static/js/bundle.js',
  '/static/css/main.css',
  '/manifest.json'
]

// 安装事件
self.addEventListener('install', (event) => {
  event.waitUntil(
    caches.open(CACHE_NAME)
      .then((cache) => {
        return cache.addAll(STATIC_CACHE_URLS)
      })
      .then(() => {
        return self.skipWaiting()
      })
  )
})

// 激活事件
self.addEventListener('activate', (event) => {
  event.waitUntil(
    caches.keys().then((cacheNames) => {
      return Promise.all(
        cacheNames.map((cacheName) => {
          if (cacheName !== CACHE_NAME && cacheName !== API_CACHE_NAME) {
            return caches.delete(cacheName)
          }
        })
      )
    }).then(() => {
      return self.clients.claim()
    })
  )
})

// 拦截请求
self.addEventListener('fetch', (event) => {
  const { request } = event
  const url = new URL(request.url)

  // API请求缓存策略
  if (url.pathname.startsWith('/api/')) {
    event.respondWith(handleApiRequest(request))
    return
  }

  // 静态资源缓存策略
  if (request.destination === 'document') {
    event.respondWith(handleNavigationRequest(request))
    return
  }

  // 其他资源缓存策略
  event.respondWith(handleResourceRequest(request))
})

// 处理API请求 - 网络优先，缓存备用
async function handleApiRequest(request) {
  try {
    const response = await fetch(request)
  
    if (response.ok) {
      const cache = await caches.open(API_CACHE_NAME)
      cache.put(request, response.clone())
    }
  
    return response
  } catch (error) {
    const cachedResponse = await caches.match(request)
    if (cachedResponse) {
      return cachedResponse
    }
  
    // 返回离线页面或默认响应
    return new Response(
      JSON.stringify({ error: '网络连接失败，请检查网络设置' }),
      {
        status: 503,
        headers: { 'Content-Type': 'application/json' }
      }
    )
  }
}

// 处理导航请求 - 缓存优先
async function handleNavigationRequest(request) {
  const cachedResponse = await caches.match(request)
  if (cachedResponse) {
    return cachedResponse
  }
  
  try {
    const response = await fetch(request)
    const cache = await caches.open(CACHE_NAME)
    cache.put(request, response.clone())
    return response
  } catch (error) {
    // 返回缓存的首页
    return caches.match('/')
  }
}

// 处理资源请求 - 缓存优先
async function handleResourceRequest(request) {
  const cachedResponse = await caches.match(request)
  if (cachedResponse) {
    return cachedResponse
  }
  
  try {
    const response = await fetch(request)
    if (response.ok) {
      const cache = await caches.open(CACHE_NAME)
      cache.put(request, response.clone())
    }
    return response
  } catch (error) {
    return new Response('资源加载失败', { status: 404 })
  }
}

// 后台同步
self.addEventListener('sync', (event) => {
  if (event.tag === 'background-sync') {
    event.waitUntil(doBackgroundSync())
  }
})

async function doBackgroundSync() {
  // 处理离线时的数据同步
  const pendingRequests = await getPendingRequests()
  
  for (const request of pendingRequests) {
    try {
      await fetch(request)
      await removePendingRequest(request)
    } catch (error) {
      console.error('后台同步失败:', error)
    }
  }
}

// 推送通知
self.addEventListener('push', (event) => {
  const options = {
    body: event.data ? event.data.text() : '您有新的消息',
    icon: '/icons/icon-192x192.png',
    badge: '/icons/badge-72x72.png',
    vibrate: [100, 50, 100],
    data: {
      dateOfArrival: Date.now(),
      primaryKey: 1
    },
    actions: [
      {
        action: 'explore',
        title: '查看详情',
        icon: '/icons/checkmark.png'
      },
      {
        action: 'close',
        title: '关闭',
        icon: '/icons/xmark.png'
      }
    ]
  }
  
  event.waitUntil(
    self.registration.showNotification('Admin Frontend', options)
  )
})

// 通知点击事件
self.addEventListener('notificationclick', (event) => {
  event.notification.close()
  
  if (event.action === 'explore') {
    event.waitUntil(
      clients.openWindow('/notifications')
    )
  }
})
```

### 3. PWA注册和管理

```typescript:src%2Fservices%2Fpwa.ts
class PWAService {
  private registration: ServiceWorkerRegistration | null = null

  async init() {
    if ('serviceWorker' in navigator) {
      try {
        this.registration = await navigator.serviceWorker.register('/sw.js')
        console.log('Service Worker注册成功')
      
        // 检查更新
        this.registration.addEventListener('updatefound', () => {
          this.handleUpdate()
        })
      
        // 请求通知权限
        await this.requestNotificationPermission()
      
        // 注册后台同步
        if ('sync' in window.ServiceWorkerRegistration.prototype) {
          await this.registration.sync.register('background-sync')
        }
      
      } catch (error) {
        console.error('Service Worker注册失败:', error)
      }
    }
  }

  private handleUpdate() {
    if (!this.registration) return
  
    const newWorker = this.registration.installing
    if (!newWorker) return
  
    newWorker.addEventListener('statechange', () => {
      if (newWorker.state === 'installed' && navigator.serviceWorker.controller) {
        // 显示更新提示
        this.showUpdateNotification()
      }
    })
  }

  private showUpdateNotification() {
    const updateBanner = document.createElement('div')
    updateBanner.innerHTML = `
      <div class="fixed top-0 left-0 right-0 bg-blue-600 text-white p-4 z-50">
        <div class="flex justify-between items-center">
          <span>发现新版本，点击更新</span>
          <button id="update-btn" class="bg-white text-blue-600 px-4 py-2 rounded">
            更新
          </button>
        </div>
      </div>
    `
  
    document.body.appendChild(updateBanner)
  
    document.getElementById('update-btn')?.addEventListener('click', () => {
      window.location.reload()
    })
  }

  async requestNotificationPermission() {
    if ('Notification' in window) {
      const permission = await Notification.requestPermission()
      return permission === 'granted'
    }
    return false
  }

  async subscribeToPush() {
    if (!this.registration) return null
  
    try {
      const subscription = await this.registration.pushManager.subscribe({
        userVisibleOnly: true,
        applicationServerKey: this.urlBase64ToUint8Array(process.env.REACT_APP_VAPID_PUBLIC_KEY!)
      })
    
      // 发送订阅信息到服务器
      await fetch('/api/push/subscribe', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json'
        },
        body: JSON.stringify(subscription)
      })
    
      return subscription
    } catch (error) {
      console.error('推送订阅失败:', error)
      return null
    }
  }

  private urlBase64ToUint8Array(base64String: string) {
    const padding = '='.repeat((4 - base64String.length % 4) % 4)
    const base64 = (base64String + padding)
      .replace(/-/g, '+')
      .replace(/_/g, '/')
  
    const rawData = window.atob(base64)
    const outputArray = new Uint8Array(rawData.length)
  
    for (let i = 0; i < rawData.length; ++i) {
      outputArray[i] = rawData.charCodeAt(i)
    }
    return outputArray
  }

  // 检查是否可以安装PWA
  canInstall(): boolean {
    return 'beforeinstallprompt' in window
  }

  // 显示安装提示
  async showInstallPrompt() {
    const event = (window as any).deferredPrompt
    if (event) {
      event.prompt()
      const { outcome } = await event.userChoice
      console.log('安装结果:', outcome)
      (window as any).deferredPrompt = null
    }
  }
}

export const pwaService = new PWAService()
```

### 4. PWA组件集成

```typescript:src%2Fcomponents%2FPWA%2FInstallPrompt.tsx
import { useState, useEffect } from 'react'
import { Download, X } from 'lucide-react'
import { pwaService } from '@/services/pwa'

export const InstallPrompt = () => {
  const [showPrompt, setShowPrompt] = useState(false)
  const [deferredPrompt, setDeferredPrompt] = useState<any>(null)

  useEffect(() => {
    const handleBeforeInstallPrompt = (e: Event) => {
      e.preventDefault()
      setDeferredPrompt(e)
      setShowPrompt(true)
    }

    window.addEventListener('beforeinstallprompt', handleBeforeInstallPrompt)

    return () => {
      window.removeEventListener('beforeinstallprompt', handleBeforeInstallPrompt)
    }
  }, [])

  const handleInstall = async () => {
    if (deferredPrompt) {
      deferredPrompt.prompt()
      const { outcome } = await deferredPrompt.userChoice
    
      if (outcome === 'accepted') {
        console.log('用户接受了安装')
      }
    
      setDeferredPrompt(null)
      setShowPrompt(false)
    }
  }

  const handleDismiss = () => {
    setShowPrompt(false)
    setDeferredPrompt(null)
  }

  if (!showPrompt) return null

  return (
    <div className="fixed bottom-4 left-4 right-4 bg-white rounded-lg shadow-lg border p-4 z-50 md:left-auto md:right-4 md:w-80">
      <div className="flex items-start justify-between">
        <div className="flex items-center space-x-3">
          <div className="bg-blue-100 rounded-full p-2">
            <Download className="h-5 w-5 text-blue-600" />
          </div>
          <div className="flex-1">
            <h3 className="text-sm font-medium text-gray-900">
              安装应用
            </h3>
            <p className="text-xs text-gray-500 mt-1">
              安装到桌面，获得更好的使用体验
            </p>
          </div>
        </div>
        <button
          onClick={handleDismiss}
          className="text-gray-400 hover:text-gray-600"
        >
          <X className="h-4 w-4" />
        </button>
      </div>
    
      <div className="mt-4 flex space-x-2">
        <button
          onClick={handleInstall}
          className="flex-1 bg-blue-600 text-white text-sm py-2 px-4 rounded-md hover:bg-blue-700 transition-colors"
        >
          安装
        </button>
        <button
          onClick={handleDismiss}
          className="flex-1 bg-gray-100 text-gray-700 text-sm py-2 px-4 rounded-md hover:bg-gray-200 transition-colors"
        >
          稍后
        </button>
      </div>
    </div>
  )
}
```

### 5. 在主应用中集成PWA

```typescript:src%2Fmain.tsx
// ... existing code ...
import { pwaService } from '@/services/pwa'

// 初始化PWA
pwaService.init()

// ... existing code ...
```

```typescript:src%2FApp.tsx
// ... existing code ...
import { InstallPrompt } from '@/components/PWA/InstallPrompt'

function App() {
  return (
    <>
      <RouterProvider router={router} />
      <InstallPrompt />
    </>
  )
}

export default App
```

---

## 总结

这三个功能的实现涵盖了现代Web应用的核心技术：

1. **实时通知系统**：提供了完整的WebSocket连接管理、消息队列处理和React组件集成
2. **文件上传管理**：实现了分片上传、断点续传、并发控制和进度监控
3. **PWA支持**：包含了Service Worker、缓存策略、离线支持和安装提示

每个功能都采用了模块化设计，便于维护和扩展。同时考虑了错误处理、性能优化和用户体验等方面。
